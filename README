The Agent class was strongly inspired by the agent principle in Clojure. Essentially, an agent wraps a shared mutable state
and hides it behind a message-passing interface. Agents accept messages and process them on behalf of the wrapped state.
typically agents accept functions / commands as messages and ensure the submitted commands are executed against the internal
agent's state in a thread-safe (sequentially).
The submitted functions / commands take the internal state as a parameter and their output becomes the new internal state value.
The code that is submitted to an agent doesn't need to pay attention to threading or synchronization, the agent will
provide such guarantees by itself.

See the examples of use for more details.

/**
 * Stores a list of names and allows concurrent threads to manipulate the list.
 */
object AgentSample {
    def main(args: Array[String]) {
        val agent: Agent[List[String]] = new Agent[List[String]](List("Joe"))
        agent.start()
        agent(List("Dave")) //Set the state to a new value
        agent((x: List[String]) => "Alice" :: x) //Pre-pend a value to the internal list
        agent.getValue((x: List[String]) => x.foreach(println _)) //Print the content asynchronously
    }
}

/**
 * Wraps a counter allowing other threads to safely update the counter concurrently
 */
object CounterSample {
    def increment(x: Long) = x + 1

    def decrement(x: Long) = x - 1

    def main(args: Array[String]) {
        val agent: Agent[Long] = new Agent[Long](0L)
        agent.start()
        agent((x: Long) => x + 100) //Increment the value by 100
        agent((x: Long) => increment(x)) //Increment the value by 1 calling the increment function
        println(agent.getValue()) //Print the content

    }
}

/**
 * A thread-safe shopping cart wrapping the internal state represented as a HashMap inside an Agent.
 * All public method calls on the ShoppingCart are transformed into a command execution on the internal agent.
 */
class ShoppingCart {
    val content: Agent[HashMap[String, Int]] = new Agent[HashMap[String, Int]](new HashMap())

    def start() { content.start()}

    def getContent() : HashMap[String, Int] = { content.getValue }

    def addItem(product: String) {
        content((x: HashMap[String, Int]) => {
            x += product -> 1
            x
        })
    }

    def removeItem(product: String) {
        content((x: HashMap[String, Int]) => {
            x -= product
            x
        })
    }

    def clear() {
        content((x: HashMap[String, Int]) => {
            x.clear()
            x
        })
    }
}

object ShoppingCartExample {
    def main(args: Array[String]) {
        val cart: ShoppingCart = new ShoppingCart
        cart.start()

        cart.addItem("Budweiser")
        cart.addItem("Pilsner")
        cart.addItem("Staropramen")
        cart.removeItem("Budweiser")

        println(cart.getContent())
        cart.clear()
        println(cart.getContent())

    }
}
